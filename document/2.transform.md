# Transform

- ê¸°ë³¸ì ì¸ Transform(í¬ê¸°, ì´ë™, íšŒì „)ì„ ì•Œì•„ë³´ë ¤ê³ í•œë‹¤.
- Meshì˜ ê³µí†µ ì†ì„±ë“¤ì€ [Object3D](https://threejs.org/docs/index.html?q=Mesh#api/en/core/Object3D)ì— ì •ì˜ë˜ì–´ìˆë‹¤.

## Object3D í´ë˜ìŠ¤ì˜ ì£¼ìš” ê³µí†µ ì†ì„±ë“¤

- position: ê°ì²´ì˜ ìœ„ì¹˜
- rotation: ê°ì²´ì˜ íšŒì „
- scale: ê°ì²´ì˜ í¬ê¸°
- quaternion: íšŒì „ì„ í‘œí˜„í•˜ëŠ” ë‹¤ë¥¸ ë°©ì‹
- visible: ê°ì²´ì˜ ê°€ì‹œì„±
- parent: ë¶€ëª¨ ê°ì²´
- children: ìì‹ ê°ì²´ë“¤
- up: ê°ì²´ì˜ "ìœ„" ë°©í–¥

- ì—¬ê¸°ì„œ ì•Œì•„ë³´ê³  ì‹¶ì€ ì†ì„±ì€ position, rotation, scale, quaternionì´ë‹¤.

## position

- positionì˜ typeì€ Vector3ë‹¤.
- Vector3ëŠ” Three.jsì—ì„œ 3ì°¨ì› ë²¡í„°ë¥¼ ë‚˜íƒ€ë‚´ëŠ” í´ë˜ìŠ¤ë‹¤.
- x,y,z ê°’ì„ ê°€ì§€ê³  ê¸°ë³¸ê°’ì€ (0,0,0)ì´ë‹¤.

```ts
const cube = Mesh(geometry, material);

cube.position.x = 1;
cube.position.y = 2;
cube.position.z = 3;

cube.position.set(1, 2, 3);
cube.position.add(new THREE.Vector(0, 1, 0));
```

### setê³¼ add(new THREE.Vector)ì˜ ì°¨ì´

- setì€ ì ˆëŒ€ì ì¸ ìœ„ì¹˜ ì§€ì •í•  ë•Œ ì‚¬ìš©í•œë‹¤. ê°ì²´ë¥¼ íŠ¹ì • ìœ„ì¹˜ë¡œ ì¦‰ì‹œ ì´ë™ì‹œí‚¤ê³  ì‹¶ì„ ë•ŒëŠ” setì„ ì‚¬ìš©í•œë‹¤.
- addëŠ” ìƒëŒ€ì ì¸ ì´ë™ì„ í•  ë•Œ ì‚¬ìš©í•œë‹¤. í˜„ì¬ ìœ„ì¹˜ì—ì„œ ì¼ì • ê±°ë¦¬ë§Œí¼ ì´ë™ì‹œí‚¤ê³  ì‹¶ì„ ë•ŒëŠ” addë¥¼ ì‚¬ìš©í•œë‹¤.

## scale

- scaleì˜ íƒ€ì…ì€ Vector3ë‹¤.

```ts
const cube = Mesh(geometry, material);

cube.scale.x = 1;
cube.scale.y = 2;
cube.scale.z = 3;

cube.scale.set(1, 2, 3);
```

## rotation

- rotationì˜ íƒ€ì…ì€ Eulerë‹¤.
- ë‹¨ìœ„ëŠ” ë¼ë””ì•ˆì´ë‹¤.
- ğ›‘ = 180ë„

```ts
const pi = Math.PI; // 180ë„
```

ì™ ì§€ ë¡œí…Œì´ì…˜ ê³„ì‚°í•  ë•Œ ê°ë„ë¡œ í•˜ëŠ”ê²Œ í›¨ì”¬ í¸í•  ê²ƒ ê°™ë‹¤.

> ê°ë„ë¥¼ ë„(degree)ì—ì„œ ë¼ë””ì•ˆìœ¼ë¡œ ë³€í™˜í•  ë•ŒëŠ” THREE.MathUtils.degToRad() í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
> .degToRad ( degrees : Float ) : Float
>
> - Converts degrees to radians.

```ts
const cube = Mesh(geometry, material);
cube.rotation.set(Math.PI / 4, 0, Math.PI / 2);

cube.rotation.x = Math.PI / 4;
cube.rotation.y = 0;
cube.rotation.z = Math.PI / 2;
```

## quaternion

Quaternionì€ Three.jsì—ì„œ ì£¼ë¡œ ë‹¤ìŒê³¼ ê°™ì€ ë°©ì‹ìœ¼ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤

ì¶•ê³¼ ê°ë„ë¡œ íšŒì „ ì„¤ì •:

```javascript
const axis = new THREE.Vector3(0, 1, 0); // Yì¶•
const angle = Math.PI / 2; // 90ë„
object.quaternion.setFromAxisAngle(axis, angle);
```

Euler ê°ì—ì„œ ë³€í™˜:

```javascript
const euler = new THREE.Euler(0, Math.PI / 2, 0); // Yì¶•ìœ¼ë¡œ 90ë„ íšŒì „
object.quaternion.setFromEuler(euler);
```

ë‘ ë²¡í„° ì‚¬ì´ì˜ íšŒì „:

```javascript
const from = new THREE.Vector3(0, 0, 1);
const to = new THREE.Vector3(1, 0, 0);
object.quaternion.setFromUnitVectors(from, to);
```

íšŒì „ ë³´ê°„ (Slerp)

- íšŒì „ ë³´ê°„(Rotation Interpolation)ì€ 3D ê·¸ë˜í”½ìŠ¤ì™€ ì• ë‹ˆë©”ì´ì…˜ì—ì„œ ì¤‘ìš”í•œ ê°œë…ì…ë‹ˆë‹¤. ë‘ íšŒì „ ìƒíƒœ ì‚¬ì´ë¥¼ ë¶€ë“œëŸ½ê²Œ ì „í™˜í•˜ëŠ” ê³¼ì •ì„ ë§í•©ë‹ˆë‹¤.

ì£¼ìš” íŠ¹ì§•ê³¼ ìš©ë„:

- ì •ì˜

  - ì‹œì‘ íšŒì „ê³¼ ë íšŒì „ ì‚¬ì´ì˜ ì¤‘ê°„ ìƒíƒœë¥¼ ê³„ì‚°í•˜ëŠ” ê³¼ì •ì…ë‹ˆë‹¤.

- ëª©ì 

  - ë¶€ë“œëŸ¬ìš´ íšŒì „ ì• ë‹ˆë©”ì´ì…˜ì„ ë§Œë“­ë‹ˆë‹¤.
  - ê°‘ì‘ìŠ¤ëŸ¬ìš´ íšŒì „ ë³€í™”ë¥¼ ë°©ì§€í•©ë‹ˆë‹¤.

- ë°©ë²•

  - Quaternionì„ ì‚¬ìš©í•œ SLERP (Spherical Linear Interpolation)ê°€ ê°€ì¥ ì¼ë°˜ì ì…ë‹ˆë‹¤.
  - SLERPëŠ” íšŒì „ì„ êµ¬ë©´ ìƒì˜ ìµœë‹¨ ê²½ë¡œë¡œ ë³´ê°„í•©ë‹ˆë‹¤.

- ì¥ì 

  - Gimbal lock ë¬¸ì œë¥¼ í”¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
  - ìì—°ìŠ¤ëŸ¬ìš´ íšŒì „ ê²½ë¡œë¥¼ ì œê³µí•©ë‹ˆë‹¤.

- ì‘ìš©

  - ì¹´ë©”ë¼ ì „í™˜
  - ìºë¦­í„° ì• ë‹ˆë©”ì´ì…˜
  - ë¬¼ì²´ì˜ ë°©í–¥ ì „í™˜

- ì˜ˆì‹œ ì‹œë‚˜ë¦¬ì˜¤
  - ê²Œì„ì—ì„œ ìºë¦­í„°ê°€ í•œ ë°©í–¥ì—ì„œ ë‹¤ë¥¸ ë°©í–¥ìœ¼ë¡œ ë¶€ë“œëŸ½ê²Œ ëŒì•„ë³´ëŠ” ê²½ìš°
  - ìš°ì£¼ì„  ì‹œë®¬ë ˆì´ì…˜ì—ì„œ ìš°ì£¼ì„ ì˜ ë°©í–¥ì„ ë¶€ë“œëŸ½ê²Œ ë³€ê²½í•˜ëŠ” ê²½ìš°

```js
const startQuaternion = new THREE.Quaternion();
const endQuaternion = new THREE.Quaternion().setFromEuler(
  new THREE.Euler(0, Math.PI, 0)
);
const t = 0.5; // ë³´ê°„ íŒ©í„° (0ì—ì„œ 1 ì‚¬ì´)
object.quaternion.slerpQuaternions(startQuaternion, endQuaternion, t);
```

ë‹¤ë¥¸ Quaternionê³¼ ê³±í•˜ê¸° (íšŒì „ ê²°í•©):

```javascript
const rotation1 = new THREE.Quaternion().setFromEuler(
  new THREE.Euler(0, Math.PI / 2, 0)
);
const rotation2 = new THREE.Quaternion().setFromEuler(
  new THREE.Euler(Math.PI / 2, 0, 0)
);

object.quaternion.multiplyQuaternions(rotation1, rotation2);
```

ì¹´ë©”ë¼ë‚˜ ê°ì²´ë¥¼ íŠ¹ì • ë°©í–¥ìœ¼ë¡œ í–¥í•˜ê²Œ í•˜ê¸°:

```javascript
const target = new THREE.Vector3(10, 0, 0);
object.lookAt(target);
// lookAt ë©”ì„œë“œëŠ” ë‚´ë¶€ì ìœ¼ë¡œ quaternionì„ ì‚¬ìš©í•©ë‹ˆë‹¤
```

ì• ë‹ˆë©”ì´ì…˜ì—ì„œ ë¶€ë“œëŸ¬ìš´ íšŒì „:

```javascript
function animate() {
  requestAnimationFrame(animate);

  // ë§¤ í”„ë ˆì„ë§ˆë‹¤ ì¡°ê¸ˆì”© íšŒì „
  const rotationIncrement = new THREE.Quaternion().setFromEuler(
    new THREE.Euler(0, 0.01, 0)
  );
  object.quaternion.multiply(rotationIncrement);

  renderer.render(scene, camera);
}
```

Quaternionì„ ì§ì ‘ ë‹¤ë£¨ëŠ” ê²ƒë³´ë‹¤ Three.jsì—ì„œ ì œê³µí•˜ëŠ” ì´ëŸ¬í•œ ë©”ì„œë“œë“¤ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¼ë°˜ì ìœ¼ë¡œ ë” ì‰½ê³  ì•ˆì „í•©ë‹ˆë‹¤. ì´ ë°©ë²•ë“¤ì„ í†µí•´ ë³µì¡í•œ 3D íšŒì „ì„ íš¨ê³¼ì ìœ¼ë¡œ ì²˜ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### ì˜ˆì‹œ

- [misc animation keys](https://threejs.org/examples/#misc_animation_keys)
- [misc animation keys - ì½”ë“œ](https://github.com/mrdoob/three.js/blob/master/examples/misc_animation_keys.html)
